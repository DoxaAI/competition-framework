# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: proto/scheduling.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class EvaluationSubmission(betterproto.Message):
    """Schedule batch of evaluations"""

    agent_ids: List[int] = betterproto.int32_field(1)
    """Agent participants (the same agent may appear multiple times)"""

    metadata: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ScheduleEvaluationBatchRequest(betterproto.Message):
    competition_tag: str = betterproto.string_field(1)
    evaluations: List["EvaluationSubmission"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ScheduleEvaluationBatchResponse(betterproto.Message):
    batch_id: int = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class CompleteEvaluationRequest(betterproto.Message):
    """Mark an evaluation as completed (and release the worker)"""

    evaluation_id: int = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class CompleteEvaluationResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class RegisterDriverRequest(betterproto.Message):
    """Driver registration & deregistration"""

    runtime_id: str = betterproto.string_field(1)
    competition_tags: List[str] = betterproto.string_field(2)
    endpoint: str = betterproto.string_field(3)
    workers: int = betterproto.int32_field(4)


@dataclass(eq=False, repr=False)
class RegisterDriverResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeregisterDriverRequest(betterproto.Message):
    runtime_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class DeregisterDriverResponse(betterproto.Message):
    pass


class UmpireSchedulingServiceStub(betterproto.ServiceStub):
    async def schedule_evaluation_batch(
        self,
        schedule_evaluation_batch_request: "ScheduleEvaluationBatchRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ScheduleEvaluationBatchResponse":
        return await self._unary_unary(
            "/umpire.scheduling.UmpireSchedulingService/ScheduleEvaluationBatch",
            schedule_evaluation_batch_request,
            ScheduleEvaluationBatchResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def complete_evaluation(
        self,
        complete_evaluation_request: "CompleteEvaluationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CompleteEvaluationResponse":
        return await self._unary_unary(
            "/umpire.scheduling.UmpireSchedulingService/CompleteEvaluation",
            complete_evaluation_request,
            CompleteEvaluationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def register_driver(
        self,
        register_driver_request: "RegisterDriverRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RegisterDriverResponse":
        return await self._unary_unary(
            "/umpire.scheduling.UmpireSchedulingService/RegisterDriver",
            register_driver_request,
            RegisterDriverResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def deregister_driver(
        self,
        deregister_driver_request: "DeregisterDriverRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeregisterDriverResponse":
        return await self._unary_unary(
            "/umpire.scheduling.UmpireSchedulingService/DeregisterDriver",
            deregister_driver_request,
            DeregisterDriverResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class UmpireSchedulingServiceBase(ServiceBase):
    async def schedule_evaluation_batch(
        self, schedule_evaluation_batch_request: "ScheduleEvaluationBatchRequest"
    ) -> "ScheduleEvaluationBatchResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def complete_evaluation(
        self, complete_evaluation_request: "CompleteEvaluationRequest"
    ) -> "CompleteEvaluationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def register_driver(
        self, register_driver_request: "RegisterDriverRequest"
    ) -> "RegisterDriverResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def deregister_driver(
        self, deregister_driver_request: "DeregisterDriverRequest"
    ) -> "DeregisterDriverResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_schedule_evaluation_batch(
        self,
        stream: "grpclib.server.Stream[ScheduleEvaluationBatchRequest, ScheduleEvaluationBatchResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.schedule_evaluation_batch(request)
        await stream.send_message(response)

    async def __rpc_complete_evaluation(
        self,
        stream: "grpclib.server.Stream[CompleteEvaluationRequest, CompleteEvaluationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.complete_evaluation(request)
        await stream.send_message(response)

    async def __rpc_register_driver(
        self,
        stream: "grpclib.server.Stream[RegisterDriverRequest, RegisterDriverResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.register_driver(request)
        await stream.send_message(response)

    async def __rpc_deregister_driver(
        self,
        stream: "grpclib.server.Stream[DeregisterDriverRequest, DeregisterDriverResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.deregister_driver(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/umpire.scheduling.UmpireSchedulingService/ScheduleEvaluationBatch": grpclib.const.Handler(
                self.__rpc_schedule_evaluation_batch,
                grpclib.const.Cardinality.UNARY_UNARY,
                ScheduleEvaluationBatchRequest,
                ScheduleEvaluationBatchResponse,
            ),
            "/umpire.scheduling.UmpireSchedulingService/CompleteEvaluation": grpclib.const.Handler(
                self.__rpc_complete_evaluation,
                grpclib.const.Cardinality.UNARY_UNARY,
                CompleteEvaluationRequest,
                CompleteEvaluationResponse,
            ),
            "/umpire.scheduling.UmpireSchedulingService/RegisterDriver": grpclib.const.Handler(
                self.__rpc_register_driver,
                grpclib.const.Cardinality.UNARY_UNARY,
                RegisterDriverRequest,
                RegisterDriverResponse,
            ),
            "/umpire.scheduling.UmpireSchedulingService/DeregisterDriver": grpclib.const.Handler(
                self.__rpc_deregister_driver,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeregisterDriverRequest,
                DeregisterDriverResponse,
            ),
        }
